---
layout: page
date: 2012-01-15
time: "09:00:00"
authors: ["Greg Wilson"]
title: Why Is This Hard?
tags: ["Education", "Software Carpentry"]
---

<p><b>This post originally appeared on the <a href="https://software-carpentry.org/">Software Carpentry website.</a></b></p>
<p>I've been teaching scientists to program since 1998 (or 1986, if you want to start with my first lunch-and-learn for grad students in physics at the University of Edinburgh). Technology has advanced by leaps and bounds in that time, but I don't think it's any easier than it used to be to get basic software skills into people's heads. What makes it hard?</p>
<p><strong>Programming is intrinsically difficult.</strong> It's fashionable to claim otherwise, but abstract thinking is a fairly recent innovation in evolutionary terms, and our brains still find it hard. On the other hand, I don't believe that state machines and data transformations are any <em>harder</em> than high school algebra, and everyone we're trying to help has long since mastered that.</p>
<p><strong>Today's languages and tools make it more difficult.</strong> <a href="{{site.baseurl}}/blog/2011/12/it-just-keeps-on-hurting.html">Setup</a> (particularly <a href="{{site.baseurl}}/blog/2011/11/quantifying-installation-costs.html">installation</a>) is, if anything, harder than it was twenty years ago, and even the <a href="http://www.python.org">cleanest</a> <a href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29">languages</a> are full of <a href="http://en.wikipedia.org/wiki/Accidental_complexity">accidental complexity</a> (particularly in their libraries). (And if you think otherwise, try running a programming workshop for non-programmers working on half a dozen different operating systems, with two or three slightly different versions of your favorite language installed, and <em>then</em> post your dissenting comment.) It's heartening to see that people are finally reviving research from the 1970s and 1980s into the <a href="http://splashcon.org/2011/program/156">usability of programming languages</a>, but as we found out the <a href="http://www.neverworkintheory.org/?p=197">hard</a> <a href="http://www.neverworkintheory.org/?p=211">way</a>, it will be a long time before computer "scientists" start accepting scientific answers to these questions, much less acting on them.</p>
<p><strong>Our students' diverse backgrounds make teaching more difficult too.</strong> Our recent workshop at the <a href="http://www.utoronto.ca">University of Toronto</a> had students from linguistics through chemistry to astronomy. Some of them had never used a command shell before; others were their labs' unofficial sys admins, and we saw similar variation in almost every other aspect of their computing knowledge. The solution, of course, would be to divide them into levels by topic, but&mdash;</p>
<p><strong>We don't have resources to teach widely or deeply.</strong> Tens of thousands of people <em>could</em> teach scientists and engineers basic computing skills [<a href="#1">1</a>], but we have no way to reach them&mdash;yet. One of our goals for the next six months/five years is to increase the pool of instructors by several orders of magnitude [<a href="#2">2</a>]. Even on a five-year timescale, though, we'll have to continue to rely mostly on volunteers, because&mdash;</p>
<p><strong>There's no room for computing in the curriculum.</strong> More precisely, faculty won't make room, because they think computing is less important than thermodynamics, phonology, or whatever other subjects make up the core of their discipline. I used to grumble about this, but I now accept that it's a rational choice: unless and until journal reviewers and grant agencies start asking hard question about how scientists produce their computational results, investing time in improving computational skills is a cost with uncertain rewards. And yes, there are a few exceptions here and there, but until we move to five- or six-year undergraduate degrees, they'll continue to be exceptions. Realistically, I think the best we can hope for in the next decade is that computing has the same standing as statistics, i.e., everybody has to know the basics because their other work depends on it, but more advanced knowledge is acquired on a discipline-specific need-to-know basis.</p>
<p><strong>Follow-through is hard.</strong> OK, so you just spent a couple of days at some kind of workshop: what now? If you're lucky, you learned enough about Python or the shell to start automating a few data analysis tasks, so a positive feedback loop will kick in. But if the problem in front of you is to speed up 80,000 lines of legacy C++, those two days probably aren't going to make a big difference. Yes, there are a lot of tutorials online that are supposed to help you, but in practice, you'll probably find those more frustrating than anything else they assume a lot of background knowledge you don't have, so you're not sure which ones actually move you closer to your goal. The proposed <a href="http://area51.stackexchange.com/proposals/28815/scientific-computing-was-computational-science">Computational Science</a> area at <a href="http://stackexchange.com/">Stack Exchange</a> might help here, if it takes off, and we're hoping that running lesson-a-week online classes after workshops will help too, but it will always be hard for people to find time for "deep" learning, which is precisely what will make the <em>next</em> problem they run into easier to solve.</p>
<p><strong>Most of today's online teaching tools implement bad models of teaching.</strong> We've known for decades&mdash;literally, decades&mdash;that watching a video and doing some exercises is a lousy way to teach (see recent posts by <a href="http://fnoschese.wordpress.com/tag/khan-academy/">Frank Noschese</a> and <a href="http://blog.oreillyschool.com/2011/12/my-thoughts-on-codecademy.html">Scott Gray</a> for discussion). In programming terms, the root of the problem is that canned instruction assumes the teacher can accurately predict how learners are going to interpret <em>and mis-interpret</em> lessons&mdash;in software engineering terms, it's plan-driven rather than adaptive. In practice, different learners will mis-interpret lessons in different (and hard-to-predict) ways; in order to be effective, teaching needs some sort of agile feedback loop to correct for this, but that's exactly what most approaches to web-based teaching take out of the equation [<a href="#3">3</a>].</p>
<p>So, is it hopeless? Of course not: over the next six months, and (hopefully) the next five years, I believe we can make real progress on several fronts. We can certainly recruit and train more workshop organizers and instructors, and experiment with different kinds of online learning to see which will make follow-through easiest and most effective (which in turn depends on us coming up with ways to assess the impact we're having). If you'd like to help, please <a href="mailto:{{site.contact}}">get in touch</a>.</p>
<p id="1">[1] I get "tens of thousands" by taking a million competent programmers, multiplying by 10% (the proportion who can teach), and then multiplying by 10% again (the proportion who might be interested). Your made-up stats may vary.</p>
<p id="2">[2] The other reason this has to be a priority is that our learners' <em>needs</em> are as diverse as their backgrounds. Our learners want to jump straight from "what's a for loop?" to "how do I detect glottal stops in lo-fi audio?" or "how do I visualize turbulent flow of interstellar gas?" We're never going to be able to cover these with just a handful of content creators.</p>
<p id="3">[3] Note that I'm using "online" to mean recorded and/or automated, i.e., things that learners can do when they want. Other approaches that deliver traditional lectures or seminars over the web synchronously and interactively are a bit better, but don't scale: no webinar system I've ever seen gives the instructor the kind of feeling for the room that s/he'd get in a regular lecture hall.</p>
