---
layout: page
date: 2012-09-04
time: "11:00:00"
authors: ["Greg Wilson"]
title: Not Really Disjoint
tags: ["Opinion", "Software Carpentry"]
---

<p><b>This post originally appeared on the <a href="https://software-carpentry.org/">Software Carpentry website.</a></b></p>
<p>The twinned discussions in bioinformatics about openness and software quality are heating up. A recent salvo on Gas Stations Without Pumps is titled "<a href="http://gasstationwithoutpumps.wordpress.com/2012/08/27/accountable-research-software/">Accountable research software</a>", and one statement in particular caught my eye:</p>
<blockquote><p><em>The rapid prototyping skills needed for research programming and the careful specification, error checking, and testing needed for software engineering are almost completely disjoint.</em></p></blockquote>
<p>I might agree that careful specification isn't needed for research programming, but error checking and testing definitely are. In fact, if we've learned anything from the agile movement in the last 15 years, it's that the more improvisatory your development process is, the more important careful craftsmanship is as well&mdash;unless, of course, you don't care whether your programs are producing correct answers or not.</p>
<p>The sentence quoted above is commentary on <a href="http://bytesizebio.net/index.php/2012/08/24/can-we-make-research-software-accountable/"> a post by a different writer</a> which is summarized as:</p>
<blockquote><p><em>...most research software is built by rapid prototyping methods, rather than careful software development methods, because we usually have no idea what algorithms and data structures are going to work when we start writing the code. The point of the research is often to discover new methods for analyzing data, which means that there are a lot of false starts and dead ends in the process... The result, however, is that research code is often incredibly difficult to distribute or maintain.</em></p></blockquote>
<p>The first part is equally true of software developed by agile teams. What saves them from the second part is developers' willingness to refactor relentlessly, which depends in turn on management's willingness to allow time for that. Developers also have to have some idea of what good software looks like, i.e., of what they ought to be refactoring <em>to</em>. Given those things, I think reusability and reproducibility would be a lot more tractable.</p>
