---
layout: page
date: 2009-07-19
time: "09:00:00"
authors: ["Greg Wilson"]
title: Day 5
tags: ["University of Alberta", "University of Toronto", "Software Carpentry"]
---

<p><b>This post originally appeared on the <a href="https://software-carpentry.org/">Software Carpentry website.</a></b></p>
<p>Day 5 of the course: <a href="http://www.cs.ualberta.ca/~paullu">Paul Lu</a> gave a lecture on Make in the morning, and students had a chance to work on problems of their choice in the afternoon. Of all the tools we teach in this course, Make is the least satisfying (at least to me): the basic concept is simple, and I wouldn't run a project without some automating repetitive tasks, but Make's syntax and limitations are repellant.</p>
<p>The problem is, the alternatives available today are equally unsatisfying. Ant requires human beings to write XML (the assembly code of the internet), and extending it requires serious skillz.  Its creator, James Duncan Davidson, said back in 2004 that if he had it to do all over again, <a href="http://www.third-bit.com/blog/archives/61.html">he'd have used a general-purpose scripting language as a base instead</a>. Lots of build systems do, including CONS, SCons, and Rake, but they're all still niche products with small user bases, weak IDE integration, and even weaker documentation.</p>
<p>Most tellingly, none of these tools has a native debugger that's as useful as breakpoint-based debuggers for conventional programming languages.  Rocky Bernstein's "<a href="http://bashdb.sourceforge.net/remake/">remake</a>" for GNU Make comes closest, but figuring out why something didn't get updated, or why hundreds of commands are executing when they're not supposed to, is still hard.  This course is now 12 years old, and for 11 of those 12 years, I've been wishing for something better to offer students so that they could see just how much work task automation could save them.  I'm still wishing...</p>
<p>Tomorrow (Monday) is Day 6 of the course; <a href="http://www.cs.utoronto.ca/~fpitt">Francois Pitt</a> will talk about computational complexity in the morning, and we'll start object-oriented programming in the afternoon. I'm enjoying it so far &mdash; hope the students are too.</p>
