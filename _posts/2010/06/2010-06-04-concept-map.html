---
layout: page
date: 2010-06-04
time: "09:00:00"
authors: ["Greg Wilson"]
title: Concept Map
tags: ["Content", "Software Carpentry"]
---

<p><b>This post originally appeared on the <a href="https://software-carpentry.org/">Software Carpentry website.</a></b></p>
<p>While re-designing the Software Carpentry course, I have realized that we rely over and over again on some underyling concepts that are hard to capture as lecture topics.  I think these concepts are the heart of any useful definition of "computational thinking".  The diagram below is a first attempt to capture what these concepts are and how they're related.  (The list below the diagram summarizes the relationships in textual form for easier reading.)  Suggestions for improvements would be very welcome...</p>
<p><img src="{{site.filesurl}}/2010/06/concept-map-300x237.png" /></p>
<table>
<tbody>
<tr>
<td>A model</td>
<td>is implemented as a</td>
<td>data structure</td>
</tr>
<tr>
<td>A model</td>
<td>must account for</td>
<td>missing or incomplete information</td>
</tr>
<tr>
<td>A data format</td>
<td>conforms to a</td>
<td>model</td>
</tr>
<tr>
<td>Instructions</td>
<td>for a computer are abstracted as an</td>
<td>algorithm</td>
</tr>
<tr>
<td>An algorithm</td>
<td>operates on a</td>
<td>model</td>
</tr>
<tr>
<td>Choice of algorithm</td>
<td>determines</td>
<td>machine performance</td>
</tr>
<tr>
<td>Data</td>
<td>is abstracted as a</td>
<td>model</td>
</tr>
<tr>
<td>Data</td>
<td>almost always has</td>
<td>missing or incomplete information</td>
</tr>
<tr>
<td>An archive</td>
<td>stores</td>
<td>data</td>
</tr>
<tr>
<td>An archive</td>
<td>conforms to a</td>
<td>data format</td>
</tr>
<tr>
<td>An archive</td>
<td>is parsed to create</td>
<td>a data structure</td>
</tr>
<tr>
<td>An abstract machine</td>
<td>is implemented by</td>
<td>a library</td>
</tr>
<tr>
<td>A program</td>
<td>is a kind of</td>
<td>data</td>
</tr>
<tr>
<td>A program</td>
<td>operates on</td>
<td>a data structure</td>
</tr>
<tr>
<td>A program</td>
<td>conforms to</td>
<td>a specification</td>
</tr>
<tr>
<td>A data structure</td>
<td>is persisted to create</td>
<td>an archive</td>
</tr>
<tr>
<td>Data structure</td>
<td>choice helps determine</td>
<td>machine performance</td>
</tr>
<tr>
<td>A specification</td>
<td>can be defined by</td>
<td>testing</td>
</tr>
<tr>
<td>Testing</td>
<td>checks</td>
<td>a program</td>
</tr>
<tr>
<td>Testing</td>
<td>requires</td>
<td>a specification</td>
</tr>
<tr>
<td>Tools</td>
<td>are</td>
<td>programs</td>
</tr>
<tr>
<td>Tools</td>
<td>support use of</td>
<td>software development techniques</td>
</tr>
<tr>
<td>Software development techniques</td>
<td>support use of</td>
<td>tools</td>
</tr>
<tr>
<td>Modularization</td>
<td>is used to structure</td>
<td>programs</td>
</tr>
<tr>
<td>Modularization</td>
<td>aids</td>
<td>testing</td>
</tr>
<tr>
<td>Modularization</td>
<td>is used to create</td>
<td>a library</td>
</tr>
<tr>
<td>Hardware</td>
<td>is represented to programmers by</td>
<td>an abstract machine</td>
</tr>
<tr>
<td>Hardware</td>
<td>architecture changes</td>
<td>machine performance</td>
</tr>
<tr>
<td>Machine performance</td>
<td>can be traded off against</td>
<td>human performance</td>
</tr>
<tr>
<td>A library</td>
<td>can extend</td>
<td>an abstract machine</td>
</tr>
<tr>
<td>Experience</td>
<td>is captured in</td>
<td>a library</td>
</tr>
<tr>
<td>Human performance</td>
<td>is determined by</td>
<td>software development techniques</td>
</tr>
<tr>
<td>Human performance</td>
<td>can be traded off against</td>
<td>machine performance</td>
</tr>
<tr>
<td>Human performance</td>
<td>depends on</td>
<td>experience</td>
</tr>
</tbody>
</table>
